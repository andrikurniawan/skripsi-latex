%-----------------------------------------------------------------------------%
\chapter{\babEmpat}
%-----------------------------------------------------------------------------%

Pada bab ini dijelaskan setiap hal yang dilakukan oleh penulis untuk melakukan implementasi terhadap rancangan yang telah dibuat pada bab sebelumnya. Penulis melakukan implementasi \textit{adaptor} yang akan dipanggil melalui \textit{template engine} dan juga melalui model lainnya. Selain itu, penulis juga melakukan \textit{refactoring business logic} dengan memanfaatkan \textit{adaptor} yang sudah diimplementasikan.

%-----------------------------------------------------------------------------%
\section{Implementasi \textit{Adaptor}}
%-----------------------------------------------------------------------------%
Sebelum melakukan implementasi \textit{adaptor}, perlu dibuat terlebih dahulu tabel \textit{rules} yang akan dibaca oleh \textit{adaptor}. Namun, karena belum adanya mekanisme pemetaan secara langsung dari \textit{rules} yang dimiliki oleh ontologi ke dalam tabel \textit{rules} maka penulis membuat tabel \textit{rules} secara manual. Tabel \textit{rules} tersebut berbentuk \textit{json} dimana strukturnya sebagai berikut

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Struktur tabel \textit{rules}},label={lst:strukturtablerules}]
{
	nama fungsi : [endpoint, jumlah parameter]
}
\end{lstlisting}
\end{minipage}

Setelah tabel rules selesai dibuat sesuai dengan struktur pada kode \ref{lst:strukturtablerules}, tabel rules tersebut disimpan ke dalam sebuah file yang bernama rules.txt dan ditaruh pada \textit{root} dari zotonic. Untuk dapat menjalankan fungsi \textit{adaptor} yang diinginkan, penulis membuat sebuah model baru pada zotonic dengan nama m\_abs pada folder \co{root/src/models}. Untuk membuat sebuah model pada zotonic, zotonic mengharuskan setiap model untuk mengekspor beberapa fungsi yang dimiliki oleh zotonic yaitu m\_find\_value, m\_to\_list, dan m\_value agar fungsi tersebut dapat digunakan melalui \textit{template engine}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Fungsi yang harus diekspor untuk model},label={lst:librarymodel}]
-export([
	m_find_value/3,
	m_to_list/2,
	m_value/2,
]).
\end{lstlisting}
\end{minipage}

Seperti yang dapat dilihat pada kode \ref{lst:librarymodel}, agar fungsi tersebut dapat dijalankan pada \textit{template engine}, tentu harus diimplementasi sesuai dengan kebutuhan. Sesuai dengan kebutuhannya agar \textit{adaptor} dapat dipanggil melalui \textit{template engine}, maka perlu didefinisikan terlebih dahulu bagaimana nantinya \textit{adaptor} dipanggil. Pada penelitian ini, penulis mendefinisikan untuk pemanggilan \textit{adaptor} pada \textit{template engine} dilakukan dengan membuat perintah \co{m.abs.namaFungsi[\{query param=value\}]}

\subsection{Pemanggilan \textit{Adaptor} Melalui \textit{Template Engine}}

Setelah didefinisikan format pemanggilan \textit{adaptor} pada \textit{template engine}, maka akan diimplementasikan pencocokan pola pada proses pemanggilan \textit{adaptor} dengan menggunakan fungsi m\_find\_value. Berikut adalah implementasi dari fungsi m\_find\_value

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Implementasi fungsi m\_find\_value},label={lst:mfindvalue}]
% this method to handle call api from template
-spec m_find_value(Key, Source, Context) -> #m{} | undefined | any() when
    Key:: integer() | atom() | string(),
    Source:: #m{},
    Context:: #context{}.

m_find_value(Type, #m{value=undefined} = M, _Context) ->
    M#m{value=[Type]};

m_find_value({query, Query}, #m{value=Q} = _, _Context) when is_list(Q) ->
	[Key] = Q,
	[Url, Param] = lookup_rules(Key),
	case validate_params(Param, Query) of
		false ->
			[{error, "Num of Params not same"}];
		true ->
			{DecodeJson} = fetch_data(binary_to_list(Url), jiffy:encode({Query})),
			lager:info("ABS result : ~p", [DecodeJson]),
			proplists:get_value(<<"data">>, DecodeJson)
	end;

% Other values won't be processed
m_find_value(_, _, _Context) ->
    undefined. 
\end{lstlisting}
\end{minipage}

Pada kode \ref{lst:mfindvalue}, tahap awal untuk mengimplementasikan fungsi m\_find\_value adalah membuat sebuah \textit{specifications} untuk fungsi yang merupakan ketentuan yang harus dipenuhi mengenai \textit{input} yang akan diterima oleh fungsi tersebut dan \textit{output} yang akan dihasilkan oleh fungsi tersebut sehingga fungsi akan dijalankan jika dan hanya jika memenuhi dari \textit{specifications} yang telah didefinisikan. Seperti yang sudah didefinisikan bahwa pemanggilan \textit{adaptor} melalui \textit{template engine} dengan cara \co{m.abs.namaFungsi[\{query param=value\}]}, maka ketika dijalankan m\_abs akan menjalankan \co{m\_find\_value(\{query, Query\}, \#m\{value=Q\})} dimana namaFungsi yang didapatkan dari hasil pemanggilan pada \textit{template engine} akan menjalankan fungsi \co{m\_find\_value(Type, \#m\{value=undefined\})} untuk yang akan mengembalikan sebuah \textit{maps} yang akan diterima kembali oleh fungsi \co{m\_find\_value(\{query, Query\}, \#m\{value=Q\})} yang menyimpan \textit{maps} hasil kembalian tersebut ke dalam variabel Q. Lalu parameter yang terdapat pada \textit{template engine} akan disimpan oleh fungsi \co{m\_find\_value(\{query, Query\}, \#m\{value=Q\})} ke dalam variabel Query.

Setelah mendapatkan informasi tentang Query dan Q, fungsi m\_find\_value selanjutnya akan mengambil \textit{key} yang akan dijalankan pada tabel \textit{rules}. Langkah pertama, akan diekstrak \textit{key} yang ingin dijalankan dari Q dengan cara \textit{pattern matching}. Setelah mendapatkan \textit{key} yang diinginkan, \textit{key} tersebut akan dijadikan sebagai input untuk pemanggilan fungsi lookup\_rules yang akan mengembalikan \textit{endpoint} yang akan dipanggil oleh m\_abs serta jumlah parameter dari fungsi yang akan dijalankan. Fungsi lookup\_rules sendiri merupakan fungsi yang membaca berkas rules.txt dan mengembalikan \textit{list} yang berisikan \textit{endpoint} dan jumlah parameter dari \textit{key} yang diberikan sebagai \textit{input}. Adapun implementasi dari fungsi lookup\_rules sebagai berikut

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Implementasi fungsi lookup\_rules},label={lst:lookuprules}]
lookup_rules(Key) ->
	File = ?RULES,
	case read_file(File) of
		{error, Error} ->
			[{error, Error}];
		[] ->
			[{error, "File empty"}];
		Json ->
			{DecodeJson} = jiffy:decode(Json),
			proplists:get_value(atom_to_binary(Key, latin1), DecodeJson)
end.

read_file(File) ->
	case file:read_file(File) of
		{ok, Data} ->
			Data;
		eof ->
			[];
		Error ->
			{error, Error}
end.
\end{lstlisting}
\end{minipage}

Pada kode \ref{lst:lookuprules}, dapat dilihat bahwa fungsi lookup\_rules akan menjalankan fungsi read\_file yang membaca seluruh isi dari file yang telah didefinisikan sebagai tabel \textit{rules}. Perlu didefinisikan juga dimana lokasi dari tabel \textit{rules} yang akan dibaca sebagai variabel final dengan nama variabel \textit{RULES} pada m\_abs seperti kode \ref{lst:pathrules}
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={lokasi dari \textit{file} rules.txt},label={lst:pathrules}]
-define(RULES, "./rules.txt").
\end{lstlisting}
\end{minipage}

Setelah mendapatkan \textit{endpoint} serta jumlah parameter dari hasil pemanggilan fungsi lookup\_rules yang berbentuk \textit{list}, \textit{list} tersebut akan diekstrak menjadi variabel Url yang menyimpan informasi \textit{endpoint} dan variabel Param yang menyimpan informasi jumlah parameter dari fungsi tersebut. Setelah mendapatkan informasi jumlah parameter, selanjutnya fungsi m\_abs akan memanggil fungsi validate\_params dengan parameter Param yang menyimpan informasi jumlah parameter dan variabel Query yang menyimpan informasi mengenai \textit{list} dari parameter yang diberikan pada \textit{template engine}. Implementasi dari fungsi validate\_params dapat dilihat sebagai berikut
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Implementasi fungsi validate\_params},label={lst:validateparams}]
validate_params(Param, Query) ->
	case length(Query) == Param of
		false ->
			false;
		true ->
			true
end.
\end{lstlisting}
\end{minipage}

Pada kode \ref{lst:validateparams}, fungsi validate\_params akan mengembalikan boolean hasil pengecekan jumlah parameter yang didapatkan dari tabel \textit{rules} dan jumlah parameter yang terdapat pada \textit{list} dari \textit{Query}. Kembalikan \textit{true} jika jumlah keduanya sama, dan kembalikan \textit{false} jika jumlahnya tidak sama.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Implementasi fungsi m\_to\_list},label={lst:mtolist}]
m_to_list(_, _Context) ->
[].
\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Implementasi fungsi m\_value},label={lst:mvalue}]
m_value(_, _Context) ->
undefined.
\end{lstlisting}
\end{minipage}

\subsection{Pemanggilan \textit{Adaptor} Melalui Model Lain}

Seperti pada gambar, tabel juga dapat diberi label dan caption. 
Caption pada tabel terletak pada bagian atas tabel. 
Contoh tabel sederhana dapat dilihat pada \tab~\ref{tab:tab1}.

\begin{table}
	\centering
	\caption{Contoh Tabel}
	\label{tab:tab1}
	\begin{tabular}{| l | c r |}
		\hline
		& kol 1 & kol 2 \\ 
		\hline
		baris 1 & 1 & 2 \\
		baris 2 & 3 & 4 \\
		baris 3 & 5 & 6 \\
		jumlah  & 9 & 12 \\
		\hline
	\end{tabular}
\end{table}

Ada jenis tabel lain yang dapat dibuat dengan \latex~berikut 
beberapa diantaranya. 
Contoh-contoh ini bersumber dari 
\url{http://en.wikibooks.org/wiki/LaTeX/Tables}

\begin{table}
	\centering
	\caption{An Example of Rows Spanning Multiple Columns}
	\label{row.spanning}
	\begin{tabular}{|l|l|*{6}{c|}}
  		\hline % create horizontal line
  		No & Name & \multicolumn{3}{|c|}{Week 1} & \multicolumn{3}{|c|}{Week 2} \\
  		\cline{3-8} % create line from 3rd column till 8th column
  		& & A & B & C & A & B & C\\
  		\hline
  		1 & Lala & 1 & 2 & 3 & 4 & 5 & 6\\
  		2 & Lili & 1 & 2 & 3 & 4 & 5 & 6\\
  		3 & Lulu & 1 & 2 & 3 & 4 & 5 & 6\\
  		\hline
	\end{tabular}
\end{table}

\begin{table}
	\centering
	\caption{An Example of Columns Spanning Multiple Rows}
	\label{column.spanning}
	\begin{tabular}{|l|c|l|}
		\hline
		Percobaan & Iterasi & Waktu \\
		\hline
		Pertama & 1 & 0.1 sec \\ \hline
		\multirow{2}{*}{Kedua} & 1 & 0.1 sec \\
 		& 3 & 0.15 sec \\ 
 		\hline
		\multirow{3}{*}{Ketiga} & 1 & 0.09 sec \\
 		& 2 & 0.16 sec \\
 		& 3 & 0.21 sec \\ 
 		\hline
	\end{tabular}
\end{table}

\begin{table}
	\centering
	\caption{An Example of Spanning in Both Directions Simultaneously}
	\label{mix.spanning}
	\begin{tabular}{cc|c|c|c|c|}
		\cline{3-6}
		& & \multicolumn{4}{|c|}{Title} \\ \cline{3-6}
		& & A & B & C & D \\ \hline
		\multicolumn{1}{|c|}{\multirow{2}{*}{Type}} &
		\multicolumn{1}{|c|}{X} & 1 & 2 & 3 & 4\\ \cline{2-6}
		\multicolumn{1}{|c|}{}                        &
		\multicolumn{1}{|c|}{Y} & 0.5 & 1.0 & 1.5 & 2.0\\ \cline{1-6}
		\multicolumn{1}{|c|}{\multirow{2}{*}{Resource}} &
		\multicolumn{1}{|c|}{I} & 10 & 20 & 30 & 40\\ \cline{2-6}
		\multicolumn{1}{|c|}{}                        &
		\multicolumn{1}{|c|}{J} & 5 & 10 & 15 & 20\\ \cline{1-6}
	\end{tabular}
\end{table}

%-----------------------------------------------------------------------------%
\section{Implementasi \textit{Refactoring Business Logic}}
%-----------------------------------------------------------------------------%
Berkas ini berisi seluruh berkas Latex yang dibaca, jadi bisa dikatakan sebagai 
berkas utama. Dari berkas ini kita dapat mengatur bab apa saja yang ingin 
kita tampilkan dalam dokumen.
